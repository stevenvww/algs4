{"root":{"data":{"id":"bu7c9xn9wio0","created":1558269047001,"text":"排序"},"children":[{"data":{"id":"bu7ca2szego0","created":1558269058230,"text":"初级排序算法"},"children":[{"data":{"id":"bu7cac5kdiw0","created":1558269078581,"text":"游戏规则"},"children":[{"data":{"id":"bu7ccmm4f8g0","created":1558269258079,"text":"主要关注对象是重新排列数组元素的算法，其中每个元素都有主键"},"children":[]},{"data":{"id":"bu7cd8905ug0","created":1558269305175,"text":"排序算法单目标就是所有元素的主键按照某种方式排序"},"children":[]},{"data":{"id":"bu7cdr74zxk0","created":1558269346421,"text":"验证算法"},"children":[{"data":{"id":"bu7ch9dzesg0","created":1558269621109,"text":"从测试代码并从数学上证明算法的正确性"},"children":[]}]},{"data":{"id":"bu7cefcdcc80","created":1558269398980,"text":"运算时间"},"children":[{"data":{"id":"bu7celju7ag0","created":1558269412492,"text":"评估算法的性能"},"children":[]},{"data":{"id":"bu7cequgyko0","created":1558269424019,"text":"需要计算比较和交换的数量，对于不交换元素的算法，计算访问数组的次数","font-weight":"bold"},"children":[]}]},{"data":{"id":"bu7cf9q48rk0","created":1558269465115,"text":"额外的内存使用"},"children":[{"data":{"id":"bu7cffzxfl40","created":1558269478769,"text":"与评估运行时间同等重要"},"children":[]},{"data":{"id":"bu7cfydl2fc0","created":1558269518776,"text":"排序算法分两类："},"children":[{"data":{"id":"bu7cg295vns0","created":1558269527216,"text":"除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的原地排序算法"},"children":[]},{"data":{"id":"bu7cgmyswig0","created":1558269572302,"text":"需要额外内存空间来存储另外一份数组副本的其他排序算法"},"children":[]}]}]}]},{"data":{"id":"bu7cjd7w2eg0","created":1558269786176,"text":"选择排序"},"children":[{"data":{"id":"bu7cjneo1ls0","created":1558269808354,"text":"什么是选择排序？"},"children":[{"data":{"id":"bu7cjq5cwgo0","created":1558269814321,"text":"1.首先，找到数组中最小的元素"},"children":[]},{"data":{"id":"bu7cjwpvnw80","created":1558269828623,"text":"2.其次，将它与数组的第一个元素交换（如果第一个元素就是最小的元素那么就和自己交换）"},"children":[]},{"data":{"id":"bu7ckixdecw0","created":1558269876965,"text":"3.再次，在剩下的元素中找到最小的元素，与数组第二个元素交换"},"children":[]},{"data":{"id":"bu7clbc7mow0","created":1558269938812,"text":"4.如此反复，直到将整个数组排序"},"children":[]},{"data":{"id":"bu7clype5ag0","created":1558269989675,"text":"简而言之它在不断地选择剩余元素之中最小者"},"children":[]}]},{"data":{"id":"bu7co5mkskg0","created":1558270161471,"text":"运行时间"},"children":[{"data":{"id":"bu7cob2vn2g0","created":1558270173341,"text":"选择排序交换的代码写在内循环外，因此交换的总次数为N，所以算法的时间效率取决于比较的次数"},"children":[]},{"data":{"id":"bu7dk7p6ta80","created":1558272673636,"text":"内循环会进行N-1-i次比较"},"children":[]},{"data":{"id":"bu7dkwrrgrk0","created":1558272728211,"text":"0~N-1次的任意i都会进行一次交换和N-1-i次比较"},"children":[]},{"data":{"id":"bu7dvg97x8g0","created":1558273554267,"text":"最坏时间复杂度\nО(n²)\n最优时间复杂度\nО(n²)\n平均时间复杂度\nО(n²)\n最坏空间复杂度\nО(n) total, O(1) auxiliary","font-style":"italic"},"children":[]}]},{"data":{"id":"bu7dw4bsjhs0","created":1558273606665,"text":"特点"},"children":[{"data":{"id":"bu7dw6dmylc0","created":1558273611130,"text":"运行时间和输入无关，比较次数与初始状态无关"},"children":[]},{"data":{"id":"bu7dwagqt080","created":1558273620025,"text":"数据移动最少；交换次数和数组的大小是线性关系"},"children":[]}]},{"data":{"id":"bu7dwvqsghk0","created":1558273666345,"text":"总结"},"children":[{"data":{"id":"bu7dxluwwlc0","created":1558273723191,"text":"1.最好情况是，已经有序，交换0次；\n2.最坏情况是，逆序，交换n-1次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多,n值较小时，选择排序比冒泡排序快。\n3.原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。","font-weight":"bold","layout_right_offset":{"x":-1,"y":0}},"children":[]}]}]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}