{"root":{"data":{"id":"bu7c9xn9wio0","created":1558269047001,"text":"排序"},"children":[{"data":{"id":"bu7ca2szego0","created":1558269058230,"text":"初级排序算法"},"children":[{"data":{"id":"bu7cac5kdiw0","created":1558269078581,"text":"游戏规则"},"children":[{"data":{"id":"bu7ccmm4f8g0","created":1558269258079,"text":"主要关注对象是重新排列数组元素的算法，其中每个元素都有主键"},"children":[]},{"data":{"id":"bu7cd8905ug0","created":1558269305175,"text":"排序算法单目标就是所有元素的主键按照某种方式排序"},"children":[]},{"data":{"id":"bu7cdr74zxk0","created":1558269346421,"text":"验证算法"},"children":[{"data":{"id":"bu7ch9dzesg0","created":1558269621109,"text":"从测试代码并从数学上证明算法的正确性"},"children":[]}]},{"data":{"id":"bu7cefcdcc80","created":1558269398980,"text":"运算时间"},"children":[{"data":{"id":"bu7celju7ag0","created":1558269412492,"text":"评估算法的性能"},"children":[]},{"data":{"id":"bu7cequgyko0","created":1558269424019,"text":"需要计算比较和交换的数量，对于不交换元素的算法，计算访问数组的次数","font-weight":"bold"},"children":[]}]},{"data":{"id":"bu7cf9q48rk0","created":1558269465115,"text":"额外的内存使用"},"children":[{"data":{"id":"bu7cffzxfl40","created":1558269478769,"text":"与评估运行时间同等重要"},"children":[]},{"data":{"id":"bu7cfydl2fc0","created":1558269518776,"text":"排序算法分两类："},"children":[{"data":{"id":"bu7cg295vns0","created":1558269527216,"text":"除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的原地排序算法"},"children":[]},{"data":{"id":"bu7cgmyswig0","created":1558269572302,"text":"需要额外内存空间来存储另外一份数组副本的其他排序算法"},"children":[]}]}]}]},{"data":{"id":"bu7cjd7w2eg0","created":1558269786176,"text":"选择排序"},"children":[{"data":{"id":"bu7cjneo1ls0","created":1558269808354,"text":"什么是选择排序？"},"children":[{"data":{"id":"bu7cjq5cwgo0","created":1558269814321,"text":"1.首先，找到数组中最小的元素"},"children":[]},{"data":{"id":"bu7cjwpvnw80","created":1558269828623,"text":"2.其次，将它与数组的第一个元素交换（如果第一个元素就是最小的元素那么就和自己交换）"},"children":[]},{"data":{"id":"bu7ckixdecw0","created":1558269876965,"text":"3.再次，在剩下的元素中找到最小的元素，与数组第二个元素交换"},"children":[]},{"data":{"id":"bu7clbc7mow0","created":1558269938812,"text":"4.如此反复，直到将整个数组排序"},"children":[]},{"data":{"id":"bu7clype5ag0","created":1558269989675,"text":"简而言之它在不断地选择剩余元素之中最小者"},"children":[]}]},{"data":{"id":"bu7co5mkskg0","created":1558270161471,"text":"运行时间"},"children":[{"data":{"id":"bu7cob2vn2g0","created":1558270173341,"text":"选择排序交换的代码写在内循环外，因此交换的总次数为N，所以算法的时间效率取决于比较的次数"},"children":[]},{"data":{"id":"bu7dk7p6ta80","created":1558272673636,"text":"内循环会进行N-1-i次比较"},"children":[]},{"data":{"id":"bu7dkwrrgrk0","created":1558272728211,"text":"0~N-1次的任意i都会进行一次交换和N-1-i次比较"},"children":[]},{"data":{"id":"bu7dvg97x8g0","created":1558273554267,"text":"最坏时间复杂度\nО(n²)\n最优时间复杂度\nО(n²)\n平均时间复杂度\nО(n²)\n最坏空间复杂度\nО(n) total, O(1) auxiliary","font-style":"italic"},"children":[]}]},{"data":{"id":"bu7dw4bsjhs0","created":1558273606665,"text":"特点"},"children":[{"data":{"id":"bu7dw6dmylc0","created":1558273611130,"text":"运行时间和输入无关，比较次数与初始状态无关"},"children":[]},{"data":{"id":"bu7dwagqt080","created":1558273620025,"text":"数据移动最少；交换次数和数组的大小是线性关系"},"children":[]}]},{"data":{"id":"bu7dwvqsghk0","created":1558273666345,"text":"总结"},"children":[{"data":{"id":"bu7dxluwwlc0","created":1558273723191,"text":"1.最好情况是，已经有序，交换0次；\n2.最坏情况是，逆序，交换n-1次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多,n值较小时，选择排序比冒泡排序快。\n3.原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。","font-weight":"bold","layout_right_offset":{"x":-1,"y":0}},"children":[]}]}]},{"data":{"id":"bud8mc3zdqw0","created":1558868094156,"text":"插入排序"},"children":[{"data":{"id":"bud8pkuk15s0","created":1558868348270,"text":"什么是插入排序？"},"children":[{"data":{"id":"bud8precjco0","created":1558868362527,"text":"构建有序序列的一种排序算法"},"children":[]},{"data":{"id":"bud8shknivk0","created":1558868576233,"text":"对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入"},"children":[]},{"data":{"id":"bud8uj2nqnc0","created":1558868736227,"text":"排序过程中，已排序的序列是有序的，但是最终的位置还不确定"},"children":[]}]},{"data":{"id":"bud901roku80","created":1558869168743,"text":"运行时间"},"children":[{"data":{"id":"bud90qeqtf40","created":1558869222380,"text":"平均情况下需要N^2/4次比较和N^2/4交换"},"children":[]},{"data":{"id":"bud917hjj940","created":1558869259555,"text":"最坏情况下需要N^2/2次比较和N^2/2次交换"},"children":[]},{"data":{"id":"bud91i5msgw0","created":1558869282779,"text":"最好情况下要N-1次比较和0次交换"},"children":[]}]},{"data":{"id":"bud908nze5k0","created":1558869183757,"text":"特点"},"children":[{"data":{"id":"bud90a75u4g0","created":1558869187093,"text":"对于非随机、部分有序数组的很有有效"},"children":[]},{"data":{"id":"bud94iqxhhc0","created":1558869519159,"text":"也很适合小规模数组"},"children":[]}]}]},{"data":{"id":"bus8wucsrtk0","created":1560392316863,"text":"希尔排序"},"children":[{"data":{"id":"bus8x0txlqg0","created":1560392330960,"text":"基本概念"},"children":[{"data":{"id":"bus8x48tey80","created":1560392338390,"text":"一种基于插入排序的快速的排序方法"},"children":[]},{"data":{"id":"bus8xg0s1tk0","created":1560392364025,"text":"由于插入排序每次只能将数据移动一位，且针对不相邻的元素十分低效，因此希尔排序应运而生"},"children":[]},{"data":{"id":"bus8y8ud8xs0","created":1560392426765,"text":"希尔排序的思想就是使数组中任意间隔为h的元素是有序的"},"children":[]}]},{"data":{"id":"bus9013e5pc0","created":1560392566624,"text":"实现方法"},"children":[{"data":{"id":"bus903hrro00","created":1560392571847,"text":"对于每个h,用插入排序将h个子数组独立地排序"},"children":[]}]},{"data":{"id":"bus922l67mo0","created":1560392726604,"text":"性能特点"},"children":[{"data":{"id":"bus924bh4mg0","created":1560392730372,"text":"1. 希尔排序权衡了子数组的规模和有序性。子数组部门有序的程度取决于递增序列的选择"},"children":[]},{"data":{"id":"bus932a8m6o0","created":1560392804307,"text":"2. 代码量小，不需要额外的内存空间，因此对于中等大小的数组它的的运行时间是可以接受的"},"children":[]}]},{"data":{"id":"bus99fagii80","created":1560393302804,"text":"时间复杂度"},"children":[{"data":{"id":"bus99hyncko0","created":1560393308620,"text":"最优：O(n), 最坏O(nlog^2n)"},"children":[]}]}]}]},{"data":{"id":"bus8nlndnco0","created":1560391592634,"text":"快速排序"},"children":[{"data":{"id":"bus8ntbpagw0","created":1560391609342,"text":"性能特点"},"children":[{"data":{"id":"bus8nxd8h200","created":1560391618142,"text":"1. 快排的优势是它的切分方法的内循环会用一个递增的索引将数组元素和一个定值比较"},"children":[]},{"data":{"id":"bus8ovddhe80","created":1560391692161,"text":"2. 快排的另一个优势是它的比较次数很少"},"children":[]},{"data":{"id":"bus8pzinl1k0","created":1560391779552,"text":"3.快排的排序效率最终依赖切分数组的效果，因此快排始终有一个缺点，切分不平衡将导致程序低效"},"children":[]}]},{"data":{"id":"bus8r8zfow80","created":1560391878522,"text":"算法改进"},"children":[{"data":{"id":"bus8rc7deyg0","created":1560391885532,"text":"1.对于小数组，切换到插入排序"},"children":[]},{"data":{"id":"bus8t59197c0","created":1560392027123,"text":"2.使用子数组的一小部分元素的中位数来切分数组，但是代价是需要计算中位数。不推荐这样处理"},"children":[]},{"data":{"id":"bus8s8h9gxk0","created":1560391955787,"text":"3.针对可能存在大量重复的数组元素情况，可以三向切分"},"children":[{"data":{"id":"bus8t255wjk0","created":1560392020359,"text":"将数组切分为三部门，分别对应小于、等于和大于切分元素的数组元素。"},"children":[]},{"data":{"id":"bus8uvagmhc0","created":1560392162170,"text":"三向切分快排最快可以达到线性级别"},"children":[]}]}]},{"data":{"id":"bus8vs59tp40","created":1560392233690,"text":"时间复杂度"},"children":[{"data":{"id":"bus8vu6vmbc0","created":1560392238141,"text":"平均和最优可以达到O(nlogn)"},"children":[]},{"data":{"id":"bus8w5bl8400","created":1560392262370,"text":"最坏时间复杂度为O(n^2)"},"children":[]}]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}